import { useToast } from '@/components/ui/toast';
import { CardService } from '@/services/cardService';
import { ApiException } from '@/services/api';
import { Card, Deck, DeckCard, DeckValidationResult } from '@/types/card';
import { FactionId } from '@/types/faction';
import { useCallback, useEffect, useMemo, useState } from 'react';

interface UseDeckProps {
  initialDeck?: Deck;
  userId?: string;
  factionId?: FactionId;
}

/**
 * Custom hook for deck building functionality
 * Handles card addition/removal and deck validation
 */
export function useDeck({
  initialDeck,
  userId,
  factionId,
}: UseDeckProps = {}) {
  const [deck, setDeck] = useState<Deck | null>(initialDeck || null);
  const [availableCards, setAvailableCards] = useState<Card[]>([]);
  const [loading, setLoading] = useState(true);
  const [validationResult, setValidationResult] = useState<DeckValidationResult | null>(null);
  const [error, setError] = useState<string | null>(null);
  const { toast } = useToast();

  // Prefer detailed error messages including backend payload when available
  const getErrorMessage = useCallback((err: unknown, fallback: string) => {
    // If axios error shape is present (before interceptor standardizes)
    if (err && typeof err === 'object') {
      const maybeResponse = (err as { response?: { data?: unknown } }).response;
      const data = maybeResponse?.data;
      if (data) {
        if (typeof data === 'string') return data;
        if (
          typeof data === 'object' &&
          data !== null &&
          'message' in (data as Record<string, unknown>) &&
          typeof (data as Record<string, unknown>).message === 'string'
        ) {
          return (data as Record<string, unknown>).message as string;
        }
        try { return JSON.stringify(data); } catch { /* ignore */ }
      }
    }
    // If our standardized ApiException
    if (err instanceof ApiException) {
      const suffix = ` (status ${err.status}${err.code ? `, code ${err.code}` : ''})`;
      return `${err.message}${suffix}`;
    }
    // Fallbacks
    if (err instanceof Error) return err.message;
    return fallback;
  }, []);

  // Map for quick lookups
  const cardMap = useMemo(() => {
    const map = new Map<string, Card>();
    availableCards.forEach(card => map.set(card.id, card));
    return map;
  }, [availableCards]);

  // Initialize a new deck
  const initNewDeck = useCallback((name: string, faction: FactionId) => {
    if (!userId) {
      setError('User ID is required to create a deck');
      return;
    }

    const newDeck: Deck = {
      id: `deck-${Date.now()}`, // Would be generated by server in real app
      userId,
      name,
      faction,
      isActive: true,
      cards: [],
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
    };

    setDeck(newDeck);
    return newDeck;
  }, [userId]);

  // Fetch available cards
  const fetchAvailableCards = useCallback(async () => {
    setLoading(true);
    setError(null);

    try {
      // In a real app, we'd filter by faction when appropriate
      const faction = factionId || deck?.faction;
      let cards: Card[];
      
      if (faction) {
        cards = await CardService.getCardsByFaction(faction);
      } else {
        const result = await CardService.searchCards({}, 1, 100);
        cards = result.cards;
      }
      
      setAvailableCards(cards);
    } catch (err) {
      const errorMessage = getErrorMessage(err, 'Failed to load available cards');
      setError(errorMessage);
      toast({
        title: 'Error',
        description: errorMessage,
        variant: 'destructive',
      });
    } finally {
      setLoading(false);
    }
  }, [factionId, deck?.faction, toast, getErrorMessage]);

  // Get maximum allowed quantity for a card
  const getMaxCardQuantity = useCallback((card: Card): number => {
    // Heroes are limited to 1 copy per deck
    if (card.type === 'hero') return 1;
    
    // Some cards might have custom limits
    if (card.abilities?.includes('Unique')) return 1;
    
    // Default limit is 3 copies per card
    return 3;
  }, []);

  // Add a card to the deck
  const addCard = useCallback((card: Card) => {
    if (!deck) {
      toast({
        title: 'Error',
        description: 'No active deck to add card to',
        variant: 'destructive',
      });
      return;
    }

    setDeck(currentDeck => {
      if (!currentDeck) return null;

      // Check if card is already in deck
      const existingCardIndex = currentDeck.cards.findIndex(dc => dc.cardId === card.id);
      let updatedCards: DeckCard[];

      if (existingCardIndex >= 0) {
        // Increment quantity if card already exists
        updatedCards = [...currentDeck.cards];
        const currentQuantity = updatedCards[existingCardIndex].quantity;
        
        // Check max allowed (usually 3, but heroes often limited to 1)
        const maxAllowed = getMaxCardQuantity(card);
        
        if (currentQuantity >= maxAllowed) {
          toast({
            title: 'Maximum reached',
            description: `You can only have ${maxAllowed} copies of ${card.name} in your deck.`,
            variant: 'destructive',
          });
          return currentDeck;
        }
        
        updatedCards[existingCardIndex] = {
          ...updatedCards[existingCardIndex],
          quantity: currentQuantity + 1,
        };
      } else {
        // Add new card with quantity 1
        updatedCards = [
          ...currentDeck.cards,
          { cardId: card.id, quantity: 1 },
        ];
      }

      return {
        ...currentDeck,
        cards: updatedCards,
        updatedAt: new Date().toISOString(),
      };
    });

    toast({
      title: 'Card added',
      description: `${card.name} added to deck.`,
      variant: 'success',
    });
  }, [deck, toast, getMaxCardQuantity]);

  // Remove a card from the deck
  const removeCard = useCallback((card: Card) => {
    if (!deck) {
      toast({
        title: 'Error',
        description: 'No active deck to remove card from',
        variant: 'destructive',
      });
      return;
    }

    setDeck(currentDeck => {
      if (!currentDeck) return null;

      // Find the card in the deck
      const existingCardIndex = currentDeck.cards.findIndex(dc => dc.cardId === card.id);
      
      // Card not in deck
      if (existingCardIndex === -1) return currentDeck;
      
      const updatedCards = [...currentDeck.cards];
      const currentQuantity = updatedCards[existingCardIndex].quantity;
      
      if (currentQuantity > 1) {
        // Reduce quantity if more than 1
        updatedCards[existingCardIndex] = {
          ...updatedCards[existingCardIndex],
          quantity: currentQuantity - 1,
        };
      } else {
        // Remove card completely if quantity is 1
        updatedCards.splice(existingCardIndex, 1);
      }

      return {
        ...currentDeck,
        cards: updatedCards,
        updatedAt: new Date().toISOString(),
      };
    });

    toast({
      title: 'Card removed',
      description: `${card.name} removed from deck.`,
    });
  }, [deck, toast]);

  // Calculate total cards in deck
  const totalCards = useMemo(() => {
    if (!deck) return 0;
    return deck.cards.reduce((sum, card) => sum + card.quantity, 0);
  }, [deck]);

  // Get deck cards with full card data
  const deckCards = useMemo(() => {
    if (!deck) return [] as { card: Card; quantity: number }[];

    return deck.cards
      .map(deckCard => {
        const card = cardMap.get(deckCard.cardId);
        return card ? { card, quantity: deckCard.quantity } : null;
      })
      .filter((item): item is { card: Card; quantity: number } => item !== null);
  }, [deck, cardMap]);

  // Get quantity of a card in the deck
  const getCardQuantity = useCallback((cardId: string): number => {
    if (!deck) return 0;
    const deckCard = deck.cards.find(dc => dc.cardId === cardId);
    return deckCard ? deckCard.quantity : 0;
  }, [deck]);

  

  // Load initial data
  useEffect(() => {
    fetchAvailableCards();
  }, [fetchAvailableCards]);

  // Validate deck whenever it changes
  useEffect(() => {
    if (!deck) {
      setValidationResult(null);
      return;
    }

    // Simple validation (real app would have more complex rules)
    const errors: string[] = [];
    const warnings: string[] = [];

    // Check total cards (usually 40-60 range)
    if (totalCards < 40) {
      errors.push(`Deck must contain at least 40 cards (currently ${totalCards})`);
    }
    if (totalCards > 60) {
      errors.push(`Deck cannot contain more than 60 cards (currently ${totalCards})`);
    }

    // Check hero card count
    const heroCards = deckCards.filter(dc => dc.card.type === 'hero');
    if (heroCards.length === 0) {
      errors.push('Deck must contain at least one hero card');
    }

    // Check faction consistency (limit total copies, not just unique cards)
    const nonFactionCards = deckCards.filter(dc => dc.card.faction !== deck.faction);
    const offFactionCopies = nonFactionCards.reduce((s, dc) => s + dc.quantity, 0);
    if (offFactionCopies > 5) {
      errors.push(
        `Deck can only include up to 5 off-faction copies (currently ${offFactionCopies})`
      );
    }

    // Calculate card type distribution
    const cardTypes = deckCards.reduce((acc, dc) => {
      acc[dc.card.type] = (acc[dc.card.type] || 0) + dc.quantity;
      return acc;
    }, {} as Record<string, number>);

    // Calculate cost curve
    const costCurve = deckCards.reduce((acc, dc) => {
      acc[dc.card.cost] = (acc[dc.card.cost] || 0) + dc.quantity;
      return acc;
    }, {} as Record<number, number>);

    // Warning for unbalanced cost curve
    const lowCostCards = Object.entries(costCurve)
      .filter(([cost]) => parseInt(cost) <= 3)
      .reduce((sum, [, count]) => sum + count, 0);

    if (lowCostCards < totalCards * 0.3) {
      warnings.push('Your deck has few low-cost cards, which may lead to slow starts');
    }

    // Set validation result
    setValidationResult({
      isValid: errors.length === 0,
      errors,
      warnings,
      cardCount: totalCards,
      heroCardCount: cardTypes['hero'] || 0,
      unitCardCount: cardTypes['unit'] || 0,
      actionCardCount: cardTypes['action'] || 0,
      structureCardCount: cardTypes['structure'] || 0,
      factionConsistency: offFactionCopies <= 5,
      energyCurveBalance: lowCostCards >= totalCards * 0.3,
      costCurve,
      factionSpecificRules: {
        // Faction-specific rule checks would go here
      },
    });

  }, [deck, deckCards, totalCards]);

  return {
    deck,
    availableCards,
    deckCards,
    loading,
    error,
    totalCards,
    validationResult,
    initNewDeck,
    addCard,
    removeCard,
    getCardQuantity,
    getMaxCardQuantity,
    refreshCards: fetchAvailableCards,
  };
}